#!/usr/bin/env perl
# Copyright [1999-2013] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;

BEGIN {
  use File::Basename;
  use File::Spec;
  my $dirname = dirname(__FILE__);
  my $lib = File::Spec->catdir($dirname, File::Spec->updir(), 'lib');
  if(-d $lib) {
    unshift(@INC, $lib);
  }
  else {
    die "Cannot find the lib directory in the expected location $lib";
  }
};

use Pod::Usage;
use Getopt::Long;
use Cwd;
use EnsEMBL::Git;

# This normally lives in ~ensembl/git-ensembl.groups or ~/git-ensembl.groups
my $CFG_FILE = 'git-ensembl.groups';
# All default ensembl repos have this public root
my $GITHUB_HTTPS_ROOT = 'https://github.com/Ensembl/';
my $GITHUB_SSH_ROOT = 'ssh://git@github.com/Ensembl/';

run();

sub run {
  my $opts = parse_command_line();
  if($opts->{list}) {
    run_list($opts);
    exit 0;
  }

  chdir $opts->{dir};
  foreach my $grp (@{$opts->{groups}}) {
    if($opts->{clone}) {
      run_clone($opts, $grp);
    }
    elsif($opts->{checkout}) {
      run_checkout($opts, $grp);
    }
    elsif($opts->{pull}) {
      run_pull($opts, $grp);
    }
    elsif($opts->{fetch}) {
      run_fetch($opts, $grp);
    }
  }
  exit 0;
}

sub parse_command_line {
  my $opts = {
    dir => cwd(),
    verbose => 1,
    help => 0,
    man => 0
  };

  GetOptions($opts, qw/
    clone
    checkout
    branch=s
    pull
    fetch
    dir=s
    groups
    list
    ssh
    name=s
    email=s
    help|?
    man
  /) or pod2usage(2);

  pod2usage(1) if $opts->{help};
  pod2usage(-exitval => 0, -verbose => 2) if $opts->{man};

  if($opts->{checkout} && ! $opts->{branch}) {
    pod2usage(-exitval => 1, -verbose => 1, -msg => 'You must a --branch when using --checkout');
  }

  # parsing grabbed the -- args so we're left with just the final groups
  if(! $opts->{list} && ! @ARGV) {
    pod2usage(-exitval => 1, -verbose => 1, -msg => 'No groups specified; please specify some');
  }
  $opts->{groups} = [map { lc($_) } @ARGV];
  return $opts;
}

sub run_clone {
  my ($opts, $group) = @_;

  _loop_modules($opts, $group, sub {
    my ($module, $remote) = @_;

    if ( -d $module) {
      print STDERR "! Skipping module as there is already a directory called that; try 'git ensembl --pull'\n";
      return;
    }

    print "* Cloning from remote '${remote}'\n";
    if(! clone($remote, $opts->{verbose})) {
      print STDERR "! Failed to clone the module '$module'\n";
      return;
    }

    # Now deal with config variables
    if($opts->{name} || $opts->{email}) {
      chdir($module);
      print "* Setting user/email config variables\n";
      add_config('user.name', $opts->{name}) if $opts->{name};
      add_config('user.email', $opts->{email}) if $opts->{email};
      chdir(File::Spec->updir());
    }

    return;
  });

  return;
}

sub run_checkout {
  my ($opts, $group) = @_;
  my $branch = $opts->{branch};
  my $verbose = $opts->{verbose};
  _loop_modules_and_chdir($opts, $group, sub {
    print "* Fetching from origin before checking out\n";
    fetch($verbose);
    print "* Checking out branch '${branch}'\n";
    if(! checkout_tracking($branch, 'origin', $verbose)) {
      printf STDERR "! Cannot switch to ${branch}\n";
      return 0;
    }
    return;
  });
  return;
}

sub run_pull {
  my ($opts, $group) = @_;
  my $branch = $opts->{branch};
  my $verbose = $opts->{verbose};
  _loop_modules_and_chdir($opts, $group, sub {
    my ($module) = @_;
    if($branch) {
      print "* Switching branches before initating pull from origin\n";
      if(! checkout_tracking($branch, 'origin', $verbose)) {
        printf STDERR "! Cannot switch to ${branch}\n";
        return 0;
      }
    }

    print "* Performing pull\n";
    pull('origin', $verbose);
    fetch('tags', $verbose);

    return;
  });
  return;
}

sub run_fetch {
  my ($opts, $group) = @_;
  _loop_modules_and_chdir($opts, $group, sub {
    my ($module) = @_;
    print "* Performing fetch\n";
    fetch(undef, $opts->{verbose});
    fetch('tags', $opts->{verbose});
    return;
  });
  return;
}

sub run_list {
  my ($opts) = @_;
  my $all_groups = get_groups($opts);
  foreach my $group (sort keys %$all_groups) {
    my $definitions = $all_groups->{$group};
    printf("[%s] - %s\n", $group, $definitions->{desc});
    printf("\t%s (%s)\n", $_, $definitions->{modules}->{$_}) for sort keys %{$definitions->{modules}};
    print "\n";
  }
  return;
}

sub _loop_modules_and_chdir {
  my ($opts, $group, $callback) = @_;
  _loop_modules($opts, $group, sub {
    my ($module, $remote) = @_;
    if (! -d $module) {
      print STDERR "! Skipping module as there is no directory called that; try 'git ensembl --clone'\n";
      return;
    }
    chdir($module);
    if(is_git_repo()) {
      $callback->($module, $remote);
    }
    else {
      print STDERR "! Skipping '${module}' because it is not a Git directory\n";
    }
    chdir(File::Spec->updir());
    return;
  });
}

# Takes a group name and a callback. We grab the modules and for each one we ask 
# the callback to process the name and it's remote URL
sub _loop_modules {
  my ($opts, $group, $callback) = @_;
  printf "* Processing group '%s'\n\n", $group;
  my $modules = get_modules($opts, $group);
  if(! keys %{$modules}) {
    print "* Cannot find any modules. Check that this group was active using --list\n";
    return;
  }

  foreach my $module (sort keys %{$modules}) {
    printf "* Working with '%s'\n", $module;
    my $remote = $modules->{$module};
    $callback->($module, $remote);
    print "\n";
  }
  return;
}

# Loop through the remainder
sub verify_groups {
  my ($opts) = @_;
  my $groups = get_groups($opts);
  foreach my $group (@{$opts->{groups}}) {
    if(! exists $groups->{$group}) {
      pod2usage(-exitval => 1, -verbose => 1, -msg => "We do not understand the group '${group}'. Please use the --list command to see all available groups");
    }
  }
  return 1;
}

sub get_modules {
  my ($opts, $group) = @_;
  my $all_groups = get_groups($opts);
  return $all_groups->{$group}->{modules};
}

sub get_groups {
  my ($opts) = @_;
  my $default = _default_groups($opts);
  my $central = _central_groups($opts);
  my $user    = _user_groups($opts);
  return {
    %{$default},
    %{$central},
    %{$user},
  };
}

# Grab the user groups from $HOME/$CFG_FILE
sub _user_groups {
  my ($opts) = @_;
  my $my_home = (getpwuid($<))[7];
  my $file = File::Spec->catfile($my_home, $CFG_FILE);
  return {} unless -f $file;
  return json($file);
}

# Grab the central groups from $ENSHOME/$CFG_FILE
sub _central_groups {
  my ($opts) = @_;
  my $ens_home = (getpwnam('ensembl'))[7];
  my $file = File::Spec->catfile($ens_home, $CFG_FILE);
  return {} unless -f $file;
  return json($file);
}

# Provide the default groups
sub _default_groups {
  my ($opts) = @_;

  my $root = ($opts->{ssh}) ? $GITHUB_SSH_ROOT : $GITHUB_HTTPS_ROOT;

  my $core_api_modules = {
    'ensembl'           => $root.'ensembl.git',
    'ensembl-compara'   => $root.'ensembl-compara.git',
    'ensembl-variation' => $root.'ensembl-variation.git',
    'ensembl-funcgen'   => $root.'ensembl-funcgen.git',
  };

  return {
    temp => {
      desc => 'Temporary group reflecting currently available github based repos',
      modules => {
        'ensembl'           => $root.'ensembl.git',
        'ensembl-compara'   => $root.'ensembl-compara.git',
      }
    },
    api => {
      desc => 'API module set used for querying and processing Ensembl data',
      modules => $core_api_modules,
    },
    tools => {
      desc => 'Libraries required to run Ensembl tools such as the VEP',
      modules => {
        %{$core_api_modules},
        'ensembl-tools' => $root.'ensembl-tools.git'
      },
    },
    production => {
      desc => 'Libraries required to run Ensembl production',
      modules => {
        %{$core_api_modules},
        'ensembl-production' => $root.'ensembl-production.git',
        'ensembl-orm' => $root.'ensembl-orm.git',
      },
    },
    rest => {
      desc => 'Libraries required to run the Ensembl REST API',
      modules => {
        %{$core_api_modules},
        'ensembl-rest' => $root.'ensembl-rest.git',
      },
    },
    web => {
      desc => 'Libraries required to run the Ensembl website',
      modules => {
        %{$core_api_modules},
        'ensembl-webcode' => $root.'ensembl-webcode.git',
        'ensembl-draw' => $root.'ensembl-draw.git',
        'ensembl-orm' => $root.'ensembl-orm.git',
        'public-plugins' => $root.'public-plugins.git',
      },
    }
  };
}



__END__
=pod

=head1 NAME

git-ensembl - Ensembl-centric Git Utility

=head1 SYNOPSIS

git ensembl [--clone [--name NAME] [--email EMAIL] ] 
            [--checkout --branch BRANCH] 
            [--pull] [--fetch] [--dir DIR] [--groups] [--list] 
            [-v] [-h] [-m] GROUPS

# List all available groups

git ensembl --list

# Clone all the API modules

git ensembl --clone api

# Clone and set a new Git username and email

git ensembl --clone --user 'Name' --email 'email@somewhere.com' api

# Clone using SSH

git ensembl --clone --ssh api

# Pull in new changes (merges into each repo's current branch)

git ensembl --pull api

# Pull in new changes on the given branch

git ensembl --pull --branch master api

# Switch to a branch in all repos or create a new remote tracking branch

git ensembl --checkout --branch global/branch api

=head1 DESCRIPTION

Provides a number of convienience actions used to clone, switch branches & pull in new changes from remote Ensembl repositories. It also provides a way of addressing multiple repositories by a group name and applying the previously mentioned functions over those groups.

All repositories are cloned using HTTPS as since Git version 1.7.10 the HTTPS protocol has been significantly changed to be as efficient as the SSH and Git protocols.

B<If you are making a read/write clone make sure you specify your username via the --user command line argument. Otherwise Git will use your default authentication details.>

=head1 SCRIPT CONFIGURATION

This script ships with a number of default configurations. You can add to these if they are in the default global location C<~ensembl/git-ensembl.groups> or your home directory at C<~/git-ensembl.groups>. The format is a permissive JSON file (accepting comments and tollerant to formatting/trailing punctuation) like so:

    {
      "groupname" : {
        "desc" : "Group description",
        "modules" : {
          "module" : "giturl",
        }
      }
    }

For example:

    {
      "coretests" : {
        "desc" : "All the modules you need to get core modules working",
        "modules" : {
          "ensembl" : "https://github.com/Ensembl/ensembl.git",
          "ensembl-test" : "https://github.com/Ensembl/ensembl-test.git",
        }
      }
    }

Configuration is resolved in the following order

=over 8

=item * User configuration

=item * Central configuration

=item * Default configuration

=back

When a clashing group is named the higher priority group takes precedence.

=head1 ACTIONS

The script can perform the following actions

=over 8

=item B<list>

Show available groups and the repos it will work with

=item B<clone>

Clone a set of repos

=item B<fetch>

Fetch a new set of changes from origin (GitHub)

=item B<checkout>

Switch branch in all repositories (will fetch from origin first and will create tracking branches where applicable)

=item B<pull>

Fetch remote changes and merge them into the current branch

=back

=head1 OPTIONS

=over 8

=item B<GROUPS>

The groups to perform actions on. Use B<--list> to find all available groups

=item B<--clone>

Clone the repositories linked to the given group (Ensembl's remote hosted on GitHub)

=item B<--ssh>

Use the SSH protocol for cloning rather than HTTPS. HTTPS is the default clone protocol

=item B<--name>

Set the config variable B<user.name> for this clone.

=item B<--email>

Set the config variable B<user.email> for this clone.

=item B<--checkout>

Checkout the branch specified in the B<--branch> command

=item B<--branch>

Branch to switch to. Used in conjunction with the B<--checkout> and B<--pull> commands

=item B<--fetch>

Fetch changes from origin and also fetch any tags

=item B<--pull>

Perform a pull from origin (Ensembl's remote hosted on GitHub) and all tags

=item B<--dir>

Perform all commands in the given directory

=item B<--list>

List all available groups

=item B<--help>

Print the help information

=item B<--man>

Print a man page

=back

=cut